'''
    تا جمع داشته باشیم تا به تارگت برسیم  n مانند سوال ۲ جمع و ۳ جمع هستش الان ما میخوایم 
    
'''

def fourSum(nums, target):
    '''
        که داریم باید حلقه بنویسیم تا تمام حالت ها را به دست بیاریم  n روش حل : ما نسبت به هر 
        به جای این که همه ی این حلفه ها را ما بنویسیم کاری میکنیم که تابع برگشتی ما این کار رو برای ما انجام بده 
        ما به ۴ تا اشاره گر نیاز داریم که ۲ تا از آنها رو تابع برگشتی ما کنترل میکند 
        در خانه ی اول و دوم قرار میگیند  jو i 
        یک خانه جلو میاد  j  قرار میگیرد و پوینتر راست در آخر هر بار کخ چپ و راست بهه هم میرسند  j پوینتر چپ بعد 
        به ۲ تا خانه آخری برسد j تا زمانی که 
        را یک خانه جلو مبیریم  i زمانی که رسید این باز  
        
        برای کنترل بهتر حافظهه چون ما تابع بازگشتی داریم و ما از استک استفاده میکنیم 
        را میریزیم توش و بعدش چپ و راست ها رو در داخلش اضافه میکنیم j و i برای همین ما یک لیست میسازیم همون اول 
        
        به آخر رسید پاکش میکنم و عدد جدیدی که به جلو آمده را به جاش اضافه میکنیم j  و زمانی که 
        
        یک لیست کلی هم که تمام حالت ها را توش ذخیره کند هم نیاز داریم 
           
    '''
    
    
    
    nums.sort()
    lst, quad = [], []
    
    # تابع بازگشتی n
    def n_sum(n, start, target): # هستش i همان  start
        if n != 2:
            for i in range(start, len(nums) - n + 1):                
                if i > start and nums[i] == nums[i - 1]:
                    continue
                quad.append(nums[i])
                n_sum(n - 1, i + 1, target - nums[i]) # به انتها برسد j این تا جایی میرود که 
                quad.pop()
            return
        
        left, right = start, len(nums) - 1
        while left < right:
            if nums[left] + nums[right] < target: # اگر مجموع کمتر از هدف باشد، اشاره‌گر چپ را افزایش می‌دهیم
                left += 1
            elif nums[left] + nums[right] > target:  # اگر مجموع بیشتر از هدف باشد، اشاره‌گر راست را کاهش می‌دهیم
                right -= 1
            else:
                lst.append(quad + [nums[left], nums[right]]) # زمانی که ما تارگت رو پیدا کردیم 
                left += 1
                
                while left < right and nums[left] == nums[left + 1]: #  جلوگیری از تکرار که احتمال دارد خانه بعدی تکراری باشد
                    left += 1
    
    n_sum(4, 0, target)
    return lst
                    
                        
        
